# priority_queue

## 实现细节

最终仅需要提交 `priority_queue.hpp` 的内容。

你需要完成的内容：

+ 构造函数（两种）
+ 析构函数
+ 赋值重载
+ 获得队首元素 `top`
+ 元素入队 `push`
+ 队首元素出队 `pop`
+ 队列大小 `size`
+ 判断队列是否为空 `empty`
+ 队列合并 `merge`

具体细节可以查看下发的 `priority_queue.hpp` 框架。

**注意：**

- 你能使用的头文件仅限于下发框架中提供的头文件；
- `merge` 复杂度不能超过 $O(\log n)$，这意味着你可能需要写可并堆；
- 有测试内存泄漏的数据点；
- `Compare` 对某些特定的数据可能会抛出异常（exception），这时你应该终止正在进行的操作并将堆恢复原样。具体而言，我们会使用一个不稳定的`cmp`，检查你的`priority_queue`在`push`，`pop`，`merge`操作时的行为。如果`cmp`没有抛出异常，我们保证cmp的返回结果是正确的，你只需要正常处理；如果cmp在某次操作的调用中抛出异常，你需要终止当前操作，把当前的`priority_queue`（如果是`merge`操作，则有两个）恢复操作前的状态，并抛出一个`runtime_error`异常。

**特别的，A 班同学在实现上有额外要求，并需要完成对应的复杂度分析报告：**

- 请在**斜堆**，**二项堆**，**配对堆**，**斐波那契堆**中选择一个来完成你的`priority_queue.hpp`。

**复杂度分析报告的要求如下：**

- 分析对象为你所实现的堆；

- 对于每个操作，分析它的时间复杂度；涉及到均摊复杂度的，请具体分析；
- 请自行根据需要来阐明堆的一些定义和性质；
- 如果选择二项堆，你需要说明 `push` 的均摊复杂度是 $O(1)$。

## 分数构成

正常情况下，在 OJ 上通过测试数据可以获得 80% 的分数，CR 占 20% 的分数。

如果在 CR 时，发现有任何违规行为（包括但不限于使用其它头文件、使用非常规方法通过测试点以及 `merge` 复杂度超过 $O(\log n)$），原则上你的最终得分将为 0 分。

## 截止日期

3 月 23 日 18:30 前